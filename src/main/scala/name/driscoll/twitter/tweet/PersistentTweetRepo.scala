package name.driscoll.twitter.tweet

import io.getquill.context.ZioJdbc.DataSourceLayer
import io.getquill.{Escape, H2ZioJdbcContext}
import io.getquill.jdbczio.Quill
import io.getquill.*
import name.driscoll.twitter.MainApp.Environment
import name.driscoll.twitter.users.{User, Users}
import zio.*
import zio.stream._

import java.time.Instant
import java.util.UUID
import javax.sql.DataSource

case class Tweets(id: Long, authorId: Long, body: String, createdAt: Instant)
case class InsertRequest(body: String, rspP: Promise[Throwable, Long])

case class PersistentTweetRepo(createQueue: Queue[InsertRequest], ds: DataSource, clock: Clock) extends TweetRepo:
  val ctx = new PostgresZioJdbcContext(SnakeCase)
  val chunkSize = 128

  import ctx._
  // Autogenerated columns. Don't include in compiled INSERT statements
  inline private implicit def tweetInsertMeta: InsertMeta[Tweets] = insertMeta[Tweets](_.id, _.createdAt)

  def createSlow(body: String): Task[Long] = {
    val authorId = 1 // TODO: Pull this out of a jwt and include it in the InsertRequest
    for
      id <- ctx.run {
        quote {
          query[Tweets].insertValue {
            lift(Tweets(0, authorId, body, Instant.now()))
          }.returningGenerated(_.id)
        }
      }
    yield id
  }.provide(ZLayer.succeed(ds))

  def createChunk(chunk: Chunk[InsertRequest]): Task[Unit] = {
    val authorId = 1L // TODO: Pull this out of a jwt and include it in the InsertRequest
    inline def statement = liftQuery(chunk.map(_.body)).foreach { r =>
      // TODO: Can we avoid specifying 0/null for autogenerated columns?
      query[Tweets].insertValue(Tweets(0, lift(authorId), r, null)).returningGenerated(_.id)
    }
//    val ids = (0 to chunk.size)
    for
//      start <- clock.instant
      ids <- ctx.run(statement, chunkSize)
//      query <- clock.instant
      _ <- ZIO.foreachDiscard(chunk.view.zip(ids))(_.rspP.succeed(_))
//      finish <- clock.instant
//      _ <- ZIO.logInfo(s"Processing ${chunk.size} took ${Duration.fromInterval(start,finish).render}. Query took  ${Duration.fromInterval(start,query).render}. Callbacks took  ${Duration.fromInterval(query,finish).render}.")
    yield ()
  }.ignore.provide(ZLayer.succeed(ds))

  override def create(body: String): Task[Long] = {
    for
      rspP <- zio.Promise.make[Throwable,Long]
      succeeded <- createQueue.offer(InsertRequest(body, rspP))
      _ <- rspP.fail(new Exception("Queue full")).unless(succeeded)
      rsp <- rspP.await
    yield (rsp)
//      ZIO.succeed(0)
  }

  override def lookup(id: String): Task[Option[Tweet]] =
    ctx.run {
      quote {
        query[Tweets].join(query[Users]).on(_.authorId==_.id)
          .filter((t, u) => t.id == lift(id.toLong))
          .map((t,u) => Tweet(author = User(u.name), body = t.body, createdAt = t.createdAt))
      }
    }.provide(ZLayer.succeed(ds)).map(_.headOption)

  override def tweets: Task[List[Tweet]] =
    ctx.run {
      quote {
        query[Tweets].join(query[Users]).on(_.authorId==_.id)
          .sortBy(_._1.id)(Ord.desc)
          .map((t,u) => Tweet(author = User(u.name), body = t.body, createdAt = t.createdAt))
          .take(10)
      }
    }.provide(ZLayer.succeed(ds))

  def worker: Task[Unit] = ZIO.scoped {
    for {
      workQueue <- ZStream.fromQueue(createQueue)
        .groupedWithin(chunkSize, 50.milliseconds)
        .toQueue(1)
      mkWorker = workQueue.take.flatMap(_.done.flatMap(c => createChunk(c.flatten))).repeat(Schedule.forever).forkScoped.unit
      _ <- mkWorker.repeatN(4)
      _ <- ZIO.never
    } yield ()
  }.fork.unit


object PersistentTweetRepo:
  def layer: ZLayer[Any, Throwable, TweetRepo] = Quill.DataSource.fromPrefix("TweetApp") >>> ZLayer {
    for
      ds <- ZIO.service[DataSource]
      createQueue <- zio.Queue.dropping[InsertRequest](1024)
      clock <- ZIO.clock
      repo = PersistentTweetRepo(createQueue, ds, clock)
      _ <- repo.worker
      _ <- createQueue.size.flatMap(s => ZIO.logInfo(s"Queue size: $s")).repeat(Schedule.fixed(1.second)).fork
    yield repo
  }

object DBTestApp extends ZIOAppDefault:
  def run: ZIO[Environment with ZIOAppArgs with Scope,Any,Any] = (for
    response <- ZIO.serviceWithZIO[TweetRepo](_.create("Hello, Tweeter!"))
  yield response).provide(
    TweetRepo.persistent,
  )


object DBTestCreateApp extends ZIOAppDefault:
  def run: ZIO[Environment with ZIOAppArgs with Scope,Any,Any] = (for
    repo <- ZIO.service[TweetRepo]
    ir <- Ref.make(0)
    _ <- ir.getAndUpdate(_+1).flatMap(i => repo.create("Hello, Tweeter " + i + "!")).fork.repeatN(50).schedule(Schedule.recurs(20000))
    _ <- ZIO.never
//    _ <- ZIO.foreachParDiscard(0 to 1000000)(i => repo.create("Hello, Tweeter " + i + "!")).withParallelism(16384)
  yield ()).provide(
    TweetRepo.persistent,
  )
