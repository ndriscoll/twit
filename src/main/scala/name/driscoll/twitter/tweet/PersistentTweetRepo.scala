package name.driscoll.twitter.tweet

import io.getquill.context.ZioJdbc.DataSourceLayer
import io.getquill.{Escape, H2ZioJdbcContext}
import io.getquill.jdbczio.Quill
import io.getquill.*
import name.driscoll.twitter.MainApp.Environment
import name.driscoll.twitter.users.{User, Users}
import zio.*
import zio.stream.{ZSink, ZStream}

import java.time.Instant
import java.util.UUID
import javax.sql.DataSource

case class Tweets(id: Long, authorId: Long, body: String, createdAt: Instant)
case class InsertRequest(body: String, rspP: Promise[Throwable, Long])

case class PersistentTweetRepo(createQueue: Queue[InsertRequest], ds: DataSource) extends TweetRepo:
  val ctx = new PostgresZioJdbcContext(SnakeCase)

  import ctx._
  // Autogenerated columns. Don't include in compiled INSERT statements
  inline private implicit def tweetInsertMeta: InsertMeta[Tweets] = insertMeta[Tweets](_.id, _.createdAt)

  def createSlow(body: String): Task[Long] = {
    val authorId = 1 // TODO: Pull this out of a jwt and include it in the InsertRequest
    for
      id <- ctx.run {
        quote {
          query[Tweets].insertValue {
            lift(Tweets(0, authorId, body, Instant.now()))
          }.returningGenerated(_.id)
        }
      }
    yield id
  }.provide(ZLayer.succeed(ds))

  def createChunk(chunk: Chunk[InsertRequest]): Task[Unit] = {
    val authorId = 1L // TODO: Pull this out of a jwt and include it in the InsertRequest
    for
      _ <- ZIO.logInfo(s"Processing ${chunk.size}")
      ids <- ctx.run {
        quote {
          liftQuery(chunk.map(_.body)).foreach { r =>
            // TODO: Can we avoid specifying 0/null for autogenerated columns?
            query[Tweets].insertValue(Tweets(0, lift(authorId), r, null)).returningGenerated(_.id)
          }
        }}
      _ <- ZStream.fromChunk(chunk).zip(ZStream.fromIterable(ids)).runForeach(_.rspP.succeed(_))
    yield ()
  }.ignore.provide(ZLayer.succeed(ds))

  override def create(body: String): Task[Long] = {
    for
      rspP <- zio.Promise.make[Throwable,Long]
      _ <- createQueue.offer(InsertRequest(body, rspP))
      rsp <- rspP.await
    yield (rsp)
  }

  override def lookup(id: String): Task[Option[Tweet]] =
    ctx.run {
      quote {
        query[Tweets].join(query[Users]).on(_.authorId==_.id)
          .filter((t, u) => t.id == lift(id.toLong))
          .map((t,u) => Tweet(author = User(u.name), body = t.body, createdAt = t.createdAt))
      }
    }.provide(ZLayer.succeed(ds)).map(_.headOption)

  override def tweets: Task[List[Tweet]] =
    ctx.run {
      quote {
        query[Tweets].join(query[Users]).on(_.authorId==_.id)
          .sortBy(_._1.id)(Ord.desc)
          .map((t,u) => Tweet(author = User(u.name), body = t.body, createdAt = t.createdAt))
          .take(10)
      }
    }.provide(ZLayer.succeed(ds))


object PersistentTweetRepo:
  def layer: ZLayer[Any, Throwable, TweetRepo] = Quill.DataSource.fromPrefix("TweetApp") >>> ZLayer {
    for
      ds <- ZIO.service[DataSource]
      createQueue <- zio.Queue.bounded[InsertRequest](16384)
      repo = PersistentTweetRepo(createQueue, ds)
      _ <- zio.stream.ZStream.fromQueue(createQueue)
        .groupedWithin(8192, 10.milliseconds)
        .run(ZSink.foreach(repo.createChunk)).forkDaemon
    yield repo
  }

object DBTestApp extends ZIOAppDefault:
  def run: ZIO[Environment with ZIOAppArgs with Scope,Any,Any] = (for
    response <- ZIO.serviceWithZIO[TweetRepo](_.create("Hello, Tweeter!"))
  yield response).provide(
    TweetRepo.persistent,
  )


object DBTestCreateApp extends ZIOAppDefault:
  def run: ZIO[Environment with ZIOAppArgs with Scope,Any,Any] = (for
    repo <- ZIO.service[TweetRepo]
    _ <- ZIO.foreachParDiscard(0 to 1000000)(i => repo.create("Hello, Tweeter " + i + "!")).withParallelism(16384)
  yield ()).provide(
    TweetRepo.persistent,
  )
